#include "shelf.h"


// Это файл с исходным кодом. Он содержит определение того, что мы обьявляли в заголовочном файле shelf.h

/*
 * Определение конструктора
 * Имя_класса::Конструктор(принимаемые на вход параметры номер и размер): поле_класса(переданный параметр)
 * много дублируется названий, но означают они разные структуры!
 */

Shelf::Shelf(unsigned int shelf_size) : shelf_size(shelf_size) {}


void Shelf::setSize(unsigned int size) {      // этот метод присваивает полке размер
    this->shelf_size = size;
}


void Shelf::addBook(PrintBook new_book) {           // этот метод добавляет книгу на полку
    if (books_list.size() < this->shelf_size) {    // проверка того, что количество книг на полке меньше размера полки
        this->books_list.push_back(new_book);     // push back добавляет элемент в конец вектора
    } else std::cout << "На полке нет места для новой книги\n";
}


/*
 * метод ниже выводит содержимое полки
 * в нем есть цикл, который перебирает все элементы вектора
 * for (класс экземпляр_класса : вектор экземпляров класса)
 * при этом вектору не важно, что именно в нем лежит,
 * перебор элементов всегда будет работать
 * для вывода используем метод класса PrintBook, выводящий книгу
 */

void Shelf::writeShelf() {
    for (PrintBook wbook : books_list) {
        wbook.writeBook();
    }
}


unsigned int Shelf::getSize() {      // этот метод возвращает количество книг на полке
    return this->books_list.size();
}


unsigned int Shelf::capacitySize() {    // этот метод возвращает размер заданной полки
    return this->shelf_size;
}


bool Shelf::findBook(std::string title, std::string author) { // этот метод проверяет, есть ли такая книга на полке
    for (PrintBook booki : books_list) {       // цикл перебирает все книги на полке, как в методе writeShelf
        if ((title == booki.getTitle()) &&    // ищем книгу с таким же названием
            (author == booki.getAuthor())){  // и автором
              return true;                  // если нашли, выходим из функции и возвращаем труе
        }
    }
    return false; // если нет, условие не сработало и мы попали сюда
}

//  а в этом методе удобнее делать цикл по-другому, с обычным счетчиком, потому что в итоге мы возвращаем счетчик
// в остальном метод похож на предыдущий

int Shelf::getPlace(std::string title, std::string author) { // этот метод возвращает место на полке для книги gbook
    for (int i = 0; i < books_list.size(); i++) {           // перебираем все места по порядку
        if ((title == books_list[i].getTitle()) &&
            (author == books_list[i].getAuthor())) {
            return i;                                    // при равенстве возвращаем i-тое место
        }
        return -1;  // если ничего не нашли, возвращаем -1 (потом станет ясно, зачем)
    }
}


void Shelf::putBook(PrintBook afterbook, PrintBook putbook) { // этот метод ставит книгу после заданной книги
    if (this->shelf_size == this->books_list.size()) {       // проверяет, есть ли свободное место на полке
        std::cout << "На полке нет места для новой книги\n";
        return;                                            // если места нет, сообщает об этом и завершается
    }
    int place = this->getPlace(afterbook.getTitle(), afterbook.getAuthor());
    // в этой переменной сохраняем место той книги, после которой надо положить новую книгу
    if (place == -1) {                        // значение -1 будет в place, если afterbook отсутствует на этой полке
        this->books_list.push_back(putbook); // в таком случае книга putbook просто добавится в конец
    } else {
        this->books_list.insert(books_list.begin() + place + 1, putbook);// если же все ок,
        // место есть и afterbook тоже есть,
        // то книга добавляется после afterbook
        // на место, равное сумме первого места в векторе (begin)
        // + место afterbook'а + 1 т к ставим после afterbook'a
    }
}


void Shelf::removeBook(std::string title, std::string author) {  // этот метод убирает заданную книгу с полки
    if (this->findBook(title, author)) {                        // проверяем, есть ли такая книга на этой полке
        books_list.erase(books_list.begin() + this->getPlace(title, author));
         // если да, то удаляем книгу с места,
        // место определяется так же как в предыдущем методе
    }
    // если нет книги, которую юзер хочет удалить, тупо ничего не делаем
}


void Shelf::removeBook(unsigned int place) { // так же как в предыдущем, но удаляем книгу с конкретного места
    if (place < books_list.size())
        books_list.erase(books_list.begin() + place);
    // если место неверное, ничего не делаем
}


//////////////////////////////// Здесь находятся методы с исключениями /////////////////////////////////////////////////

PrintBook & Shelf::getBook(std::string title, std::string author) { // эта функция очень похожа на findBook, но она
    for (PrintBook & booki : books_list) {                           // возвращает книгу, а не просто да или нет
        if ((title == booki.getTitle()) &&
            (author == booki.getAuthor())){
            return booki;
        }
    }
    throw std::domain_error("Книга с названием " + title + " и автором " + author + " не найдена\n"); // если книги нет, используем исключение
}

/*
 * исключение -- специальная команда, возвращаемая функцией,
 * если что-то пошло не так и функция не знает, что ей вернуть
 * а в объявлении функция имеет возвращаемый тип
 * т е обязательно должна вернуть какое-то значение такого типа,
 * она возвращает исключение туда, где её вызвали
 * там должна быть написана обработка этого исключения,
 * инструкция, че делать в этой ситуации
 * в моей программе вся обработка исключений находится в main.cpp
 * исключения защищают программу от неправильного ввода данных
 * я больше не могу помогите
 * но вроде понятно
 */

PrintBook & Shelf::getBook(unsigned int place) {  // тоже getBook, но уже по месту на полке
    if (place < books_list.size()){              // проверяем, не выходит ли переданное место за границы полки
        return books_list[place];               // возвращаем книгу, лежащую на переданном месте
    }
    throw std::domain_error("Нет такого места на полке"); // снова исключение -- только теперь у нас
    // неправильное место
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Shelf::~Shelf() {}
// деструктор -- удаляет всю полку. Он сам знает, как)
// он тут для порядка и красоты, можно было его не писать, он бы создался по умолчанию и подчищал бы за нами втихую.
// это верно для всех деструкторов да
